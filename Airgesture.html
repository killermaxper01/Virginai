<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking 3D Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px;
            pointer-events: none;
        }
        video { transform: scaleX(-1); display: none; }
        canvas#three-canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>

<div id="container">
    <div id="ui">
        <h2>Hand Gesture Particles</h2>
        <p>üñêÔ∏è Open Hand: Expand System</p>
        <p>‚úä Closed Fist: Contract & Change Color</p>
        <p>‚úåÔ∏è Peace Sign: Change Shape (Heart, Saturn, Flower)</p>
    </div>
    <video id="webcam" autoplay playsinline></video>
    <canvas id="three-canvas"></canvas>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';

/** * LIBRARIES: MediaPipe Hands
 * We use the CDN version of MediaPipe for ease of use in a single file.
 */
import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

// --- Configuration & State ---
let scene, camera, renderer, particles, geometry;
let handLandmarker;
let lastVideoTime = -1;
let currentShapeIndex = 0;
const particleCount = 5000;
const positions = new Float32Array(particleCount * 3);
const targets = new Float32Array(particleCount * 3);
const colors = new Float32Array(particleCount * 3);

// --- Particle Templates ---
const shapes = [
    (i) => { // Sphere/Saturn
        const phi = Math.acos(-1 + (2 * i) / particleCount);
        const theta = Math.sqrt(particleCount * Math.PI) * phi;
        return [Math.cos(theta) * Math.sin(phi), Math.sin(theta) * Math.sin(phi), Math.cos(phi)];
    },
    (i) => { // Heart
        const t = (i / particleCount) * Math.PI * 2;
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        return [x * 0.05, y * 0.05, (Math.random() - 0.5) * 0.2];
    },
    (i) => { // Flower
        const t = (i / particleCount) * Math.PI * 2;
        const r = 1 + 0.5 * Math.sin(6 * t);
        return [r * Math.cos(t), r * Math.sin(t), (Math.random() - 0.5) * 0.2];
    }
];

// --- Initialization ---
async function init() {
    // 1. Scene Setup
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    // 2. Particle System
    geometry = new THREE.BufferGeometry();
    for (let i = 0; i < particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 10;
        colors[i] = Math.random();
    }
    updateShape(0); // Set initial shape

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({ size: 0.03, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // 3. MediaPipe Setup
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
    handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task` },
        runningMode: "VIDEO", numHands: 1
    });

    startCamera();
    animate();
}

async function startCamera() {
    const video = document.getElementById('webcam');
    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
    video.srcObject = stream;
}

function updateShape(index) {
    const generator = shapes[index];
    for (let i = 0; i < particleCount; i++) {
        const [x, y, z] = generator(i);
        targets[i * 3] = x;
        targets[i * 3 + 1] = y;
        targets[i * 3 + 2] = z;
    }
}

// --- Animation Loop ---
function animate() {
    requestAnimationFrame(animate);

    const video = document.getElementById('webcam');
    if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const results = handLandmarker.detectForVideo(video, performance.now());

        if (results.landmarks && results.landmarks.length > 0) {
            const hand = results.landmarks[0];
            
            // Map hand position to particle group position
            // Flip X because webcam is mirrored
            particles.position.x = -(hand[9].x - 0.5) * 10; 
            particles.position.y = -(hand[9].y - 0.5) * 10;

            // Gesture Logic
            const thumbTip = hand[4];
            const indexTip = hand[8];
            const middleTip = hand[12];
            
            // Distance between thumb and index as a "pinch/expand" trigger
            const dist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const scale = THREE.MathUtils.mapLinear(dist, 0.05, 0.3, 0.5, 4);
            particles.scale.setScalar(scale);

            // Change color based on hand height
            const hue = hand[9].y;
            const colorAttr = geometry.attributes.color;
            for(let i=0; i<particleCount; i++) {
                const c = new THREE.Color().setHSL(hue, 0.8, 0.5);
                colorAttr.setXYZ(i, c.r, c.g, c.b);
            }
            colorAttr.needsUpdate = true;

            // Shape switcher (Middle finger high vs Index finger)
            if (middleTip.y < indexTip.y - 0.1) {
                currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                updateShape(currentShapeIndex);
            }
        }
    }

    // Smoothly lerp particles toward their targets
    const posAttr = geometry.attributes.position;
    for (let i = 0; i < particleCount * 3; i++) {
        posAttr.array[i] += (targets[i] - posAttr.array[i]) * 0.1;
    }
    posAttr.needsUpdate = true;

    particles.rotation.y += 0.01;
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

init();
</script>
</body>
</html>
